<?php
/**
 * DefaultApi
 * PHP version 5
 *
 * @category Class
 * @package  Crhg\RemoClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Nature API
 *
 * Read/Write Nature Remo
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.3.1
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Crhg\RemoClient\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Crhg\RemoClient\ApiException;
use Crhg\RemoClient\Configuration;
use Crhg\RemoClient\HeaderSelector;
use Crhg\RemoClient\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  Crhg\RemoClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation applianceOrdersPost
     *
     * @param  string $appliances List of all appliances&#39; IDs comma separated (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function applianceOrdersPost($appliances)
    {
        $this->applianceOrdersPostWithHttpInfo($appliances);
    }

    /**
     * Operation applianceOrdersPostWithHttpInfo
     *
     * @param  string $appliances List of all appliances&#39; IDs comma separated (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function applianceOrdersPostWithHttpInfo($appliances)
    {
        $returnType = '';
        $request = $this->applianceOrdersPostRequest($appliances);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation applianceOrdersPostAsync
     *
     * 
     *
     * @param  string $appliances List of all appliances&#39; IDs comma separated (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function applianceOrdersPostAsync($appliances)
    {
        return $this->applianceOrdersPostAsyncWithHttpInfo($appliances)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation applianceOrdersPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $appliances List of all appliances&#39; IDs comma separated (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function applianceOrdersPostAsyncWithHttpInfo($appliances)
    {
        $returnType = '';
        $request = $this->applianceOrdersPostRequest($appliances);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'applianceOrdersPost'
     *
     * @param  string $appliances List of all appliances&#39; IDs comma separated (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function applianceOrdersPostRequest($appliances)
    {
        // verify the required parameter 'appliances' is set
        if ($appliances === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $appliances when calling applianceOrdersPost'
            );
        }

        $resourcePath = '/appliance_orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($appliances !== null) {
            $formParams['appliances'] = ObjectSerializer::toFormValue($appliances);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appliancesApplianceAirconSettingsPost
     *
     * @param  string $appliance Appliance ID. (required)
     * @param  string $temperature Temperature (optional)
     * @param  string $operation_mode AC operation mode (optional)
     * @param  string $air_volume AC air volume (optional)
     * @param  string $air_direction AC air direction (optional)
     * @param  string $button Button (optional)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function appliancesApplianceAirconSettingsPost($appliance, $temperature = null, $operation_mode = null, $air_volume = null, $air_direction = null, $button = null)
    {
        $this->appliancesApplianceAirconSettingsPostWithHttpInfo($appliance, $temperature, $operation_mode, $air_volume, $air_direction, $button);
    }

    /**
     * Operation appliancesApplianceAirconSettingsPostWithHttpInfo
     *
     * @param  string $appliance Appliance ID. (required)
     * @param  string $temperature Temperature (optional)
     * @param  string $operation_mode AC operation mode (optional)
     * @param  string $air_volume AC air volume (optional)
     * @param  string $air_direction AC air direction (optional)
     * @param  string $button Button (optional)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function appliancesApplianceAirconSettingsPostWithHttpInfo($appliance, $temperature = null, $operation_mode = null, $air_volume = null, $air_direction = null, $button = null)
    {
        $returnType = '';
        $request = $this->appliancesApplianceAirconSettingsPostRequest($appliance, $temperature, $operation_mode, $air_volume, $air_direction, $button);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation appliancesApplianceAirconSettingsPostAsync
     *
     * 
     *
     * @param  string $appliance Appliance ID. (required)
     * @param  string $temperature Temperature (optional)
     * @param  string $operation_mode AC operation mode (optional)
     * @param  string $air_volume AC air volume (optional)
     * @param  string $air_direction AC air direction (optional)
     * @param  string $button Button (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appliancesApplianceAirconSettingsPostAsync($appliance, $temperature = null, $operation_mode = null, $air_volume = null, $air_direction = null, $button = null)
    {
        return $this->appliancesApplianceAirconSettingsPostAsyncWithHttpInfo($appliance, $temperature, $operation_mode, $air_volume, $air_direction, $button)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appliancesApplianceAirconSettingsPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $appliance Appliance ID. (required)
     * @param  string $temperature Temperature (optional)
     * @param  string $operation_mode AC operation mode (optional)
     * @param  string $air_volume AC air volume (optional)
     * @param  string $air_direction AC air direction (optional)
     * @param  string $button Button (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appliancesApplianceAirconSettingsPostAsyncWithHttpInfo($appliance, $temperature = null, $operation_mode = null, $air_volume = null, $air_direction = null, $button = null)
    {
        $returnType = '';
        $request = $this->appliancesApplianceAirconSettingsPostRequest($appliance, $temperature, $operation_mode, $air_volume, $air_direction, $button);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appliancesApplianceAirconSettingsPost'
     *
     * @param  string $appliance Appliance ID. (required)
     * @param  string $temperature Temperature (optional)
     * @param  string $operation_mode AC operation mode (optional)
     * @param  string $air_volume AC air volume (optional)
     * @param  string $air_direction AC air direction (optional)
     * @param  string $button Button (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appliancesApplianceAirconSettingsPostRequest($appliance, $temperature = null, $operation_mode = null, $air_volume = null, $air_direction = null, $button = null)
    {
        // verify the required parameter 'appliance' is set
        if ($appliance === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $appliance when calling appliancesApplianceAirconSettingsPost'
            );
        }

        $resourcePath = '/appliances/{appliance}/aircon_settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($appliance !== null) {
            $resourcePath = str_replace(
                '{' . 'appliance' . '}',
                ObjectSerializer::toPathValue($appliance),
                $resourcePath
            );
        }

        // form params
        if ($temperature !== null) {
            $formParams['temperature'] = ObjectSerializer::toFormValue($temperature);
        }
        // form params
        if ($operation_mode !== null) {
            $formParams['operation_mode'] = ObjectSerializer::toFormValue($operation_mode);
        }
        // form params
        if ($air_volume !== null) {
            $formParams['air_volume'] = ObjectSerializer::toFormValue($air_volume);
        }
        // form params
        if ($air_direction !== null) {
            $formParams['air_direction'] = ObjectSerializer::toFormValue($air_direction);
        }
        // form params
        if ($button !== null) {
            $formParams['button'] = ObjectSerializer::toFormValue($button);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appliancesApplianceDeletePost
     *
     * @param  string $appliance Appliance ID. (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function appliancesApplianceDeletePost($appliance)
    {
        $this->appliancesApplianceDeletePostWithHttpInfo($appliance);
    }

    /**
     * Operation appliancesApplianceDeletePostWithHttpInfo
     *
     * @param  string $appliance Appliance ID. (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function appliancesApplianceDeletePostWithHttpInfo($appliance)
    {
        $returnType = '';
        $request = $this->appliancesApplianceDeletePostRequest($appliance);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation appliancesApplianceDeletePostAsync
     *
     * 
     *
     * @param  string $appliance Appliance ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appliancesApplianceDeletePostAsync($appliance)
    {
        return $this->appliancesApplianceDeletePostAsyncWithHttpInfo($appliance)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appliancesApplianceDeletePostAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $appliance Appliance ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appliancesApplianceDeletePostAsyncWithHttpInfo($appliance)
    {
        $returnType = '';
        $request = $this->appliancesApplianceDeletePostRequest($appliance);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appliancesApplianceDeletePost'
     *
     * @param  string $appliance Appliance ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appliancesApplianceDeletePostRequest($appliance)
    {
        // verify the required parameter 'appliance' is set
        if ($appliance === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $appliance when calling appliancesApplianceDeletePost'
            );
        }

        $resourcePath = '/appliances/{appliance}/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($appliance !== null) {
            $resourcePath = str_replace(
                '{' . 'appliance' . '}',
                ObjectSerializer::toPathValue($appliance),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appliancesAppliancePost
     *
     * @param  string $appliance Appliance ID. (required)
     * @param  string $image Basename of the image file included in the app. Ex: \&quot;ico_ac_1\&quot; (required)
     * @param  string $nickname Appliance name (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Crhg\RemoClient\Model\Appliance
     */
    public function appliancesAppliancePost($appliance, $image, $nickname)
    {
        list($response) = $this->appliancesAppliancePostWithHttpInfo($appliance, $image, $nickname);
        return $response;
    }

    /**
     * Operation appliancesAppliancePostWithHttpInfo
     *
     * @param  string $appliance Appliance ID. (required)
     * @param  string $image Basename of the image file included in the app. Ex: \&quot;ico_ac_1\&quot; (required)
     * @param  string $nickname Appliance name (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Crhg\RemoClient\Model\Appliance, HTTP status code, HTTP response headers (array of strings)
     */
    public function appliancesAppliancePostWithHttpInfo($appliance, $image, $nickname)
    {
        $returnType = '\Crhg\RemoClient\Model\Appliance';
        $request = $this->appliancesAppliancePostRequest($appliance, $image, $nickname);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Crhg\RemoClient\Model\Appliance',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appliancesAppliancePostAsync
     *
     * 
     *
     * @param  string $appliance Appliance ID. (required)
     * @param  string $image Basename of the image file included in the app. Ex: \&quot;ico_ac_1\&quot; (required)
     * @param  string $nickname Appliance name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appliancesAppliancePostAsync($appliance, $image, $nickname)
    {
        return $this->appliancesAppliancePostAsyncWithHttpInfo($appliance, $image, $nickname)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appliancesAppliancePostAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $appliance Appliance ID. (required)
     * @param  string $image Basename of the image file included in the app. Ex: \&quot;ico_ac_1\&quot; (required)
     * @param  string $nickname Appliance name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appliancesAppliancePostAsyncWithHttpInfo($appliance, $image, $nickname)
    {
        $returnType = '\Crhg\RemoClient\Model\Appliance';
        $request = $this->appliancesAppliancePostRequest($appliance, $image, $nickname);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appliancesAppliancePost'
     *
     * @param  string $appliance Appliance ID. (required)
     * @param  string $image Basename of the image file included in the app. Ex: \&quot;ico_ac_1\&quot; (required)
     * @param  string $nickname Appliance name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appliancesAppliancePostRequest($appliance, $image, $nickname)
    {
        // verify the required parameter 'appliance' is set
        if ($appliance === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $appliance when calling appliancesAppliancePost'
            );
        }
        // verify the required parameter 'image' is set
        if ($image === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image when calling appliancesAppliancePost'
            );
        }
        // verify the required parameter 'nickname' is set
        if ($nickname === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $nickname when calling appliancesAppliancePost'
            );
        }

        $resourcePath = '/appliances/{appliance}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($appliance !== null) {
            $resourcePath = str_replace(
                '{' . 'appliance' . '}',
                ObjectSerializer::toPathValue($appliance),
                $resourcePath
            );
        }

        // form params
        if ($image !== null) {
            $formParams['image'] = ObjectSerializer::toFormValue($image);
        }
        // form params
        if ($nickname !== null) {
            $formParams['nickname'] = ObjectSerializer::toFormValue($nickname);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appliancesApplianceSignalOrdersPost
     *
     * @param  string $appliance Appliance ID. (required)
     * @param  string $signals List of all signals&#39; IDs comma separated (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function appliancesApplianceSignalOrdersPost($appliance, $signals)
    {
        $this->appliancesApplianceSignalOrdersPostWithHttpInfo($appliance, $signals);
    }

    /**
     * Operation appliancesApplianceSignalOrdersPostWithHttpInfo
     *
     * @param  string $appliance Appliance ID. (required)
     * @param  string $signals List of all signals&#39; IDs comma separated (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function appliancesApplianceSignalOrdersPostWithHttpInfo($appliance, $signals)
    {
        $returnType = '';
        $request = $this->appliancesApplianceSignalOrdersPostRequest($appliance, $signals);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation appliancesApplianceSignalOrdersPostAsync
     *
     * 
     *
     * @param  string $appliance Appliance ID. (required)
     * @param  string $signals List of all signals&#39; IDs comma separated (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appliancesApplianceSignalOrdersPostAsync($appliance, $signals)
    {
        return $this->appliancesApplianceSignalOrdersPostAsyncWithHttpInfo($appliance, $signals)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appliancesApplianceSignalOrdersPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $appliance Appliance ID. (required)
     * @param  string $signals List of all signals&#39; IDs comma separated (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appliancesApplianceSignalOrdersPostAsyncWithHttpInfo($appliance, $signals)
    {
        $returnType = '';
        $request = $this->appliancesApplianceSignalOrdersPostRequest($appliance, $signals);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appliancesApplianceSignalOrdersPost'
     *
     * @param  string $appliance Appliance ID. (required)
     * @param  string $signals List of all signals&#39; IDs comma separated (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appliancesApplianceSignalOrdersPostRequest($appliance, $signals)
    {
        // verify the required parameter 'appliance' is set
        if ($appliance === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $appliance when calling appliancesApplianceSignalOrdersPost'
            );
        }
        // verify the required parameter 'signals' is set
        if ($signals === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $signals when calling appliancesApplianceSignalOrdersPost'
            );
        }

        $resourcePath = '/appliances/{appliance}/signal_orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($appliance !== null) {
            $resourcePath = str_replace(
                '{' . 'appliance' . '}',
                ObjectSerializer::toPathValue($appliance),
                $resourcePath
            );
        }

        // form params
        if ($signals !== null) {
            $formParams['signals'] = ObjectSerializer::toFormValue($signals);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appliancesApplianceSignalsGet
     *
     * @param  string $appliance Appliance ID. (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Crhg\RemoClient\Model\Signal[]
     */
    public function appliancesApplianceSignalsGet($appliance)
    {
        list($response) = $this->appliancesApplianceSignalsGetWithHttpInfo($appliance);
        return $response;
    }

    /**
     * Operation appliancesApplianceSignalsGetWithHttpInfo
     *
     * @param  string $appliance Appliance ID. (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Crhg\RemoClient\Model\Signal[], HTTP status code, HTTP response headers (array of strings)
     */
    public function appliancesApplianceSignalsGetWithHttpInfo($appliance)
    {
        $returnType = '\Crhg\RemoClient\Model\Signal[]';
        $request = $this->appliancesApplianceSignalsGetRequest($appliance);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Crhg\RemoClient\Model\Signal[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appliancesApplianceSignalsGetAsync
     *
     * 
     *
     * @param  string $appliance Appliance ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appliancesApplianceSignalsGetAsync($appliance)
    {
        return $this->appliancesApplianceSignalsGetAsyncWithHttpInfo($appliance)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appliancesApplianceSignalsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $appliance Appliance ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appliancesApplianceSignalsGetAsyncWithHttpInfo($appliance)
    {
        $returnType = '\Crhg\RemoClient\Model\Signal[]';
        $request = $this->appliancesApplianceSignalsGetRequest($appliance);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appliancesApplianceSignalsGet'
     *
     * @param  string $appliance Appliance ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appliancesApplianceSignalsGetRequest($appliance)
    {
        // verify the required parameter 'appliance' is set
        if ($appliance === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $appliance when calling appliancesApplianceSignalsGet'
            );
        }

        $resourcePath = '/appliances/{appliance}/signals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($appliance !== null) {
            $resourcePath = str_replace(
                '{' . 'appliance' . '}',
                ObjectSerializer::toPathValue($appliance),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appliancesApplianceSignalsPost
     *
     * @param  string $message JSON serialized object describing infrared signals. Includes \&quot;data\&quot;, \&quot;freq\&quot; and \&quot;format\&quot; keys. (required)
     * @param  string $appliance Appliance ID. (required)
     * @param  string $image Basename of the image file included in the app. Ex: \&quot;ico_io\&quot; (required)
     * @param  string $name Signal name (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Crhg\RemoClient\Model\Signal
     */
    public function appliancesApplianceSignalsPost($message, $appliance, $image, $name)
    {
        list($response) = $this->appliancesApplianceSignalsPostWithHttpInfo($message, $appliance, $image, $name);
        return $response;
    }

    /**
     * Operation appliancesApplianceSignalsPostWithHttpInfo
     *
     * @param  string $message JSON serialized object describing infrared signals. Includes \&quot;data\&quot;, \&quot;freq\&quot; and \&quot;format\&quot; keys. (required)
     * @param  string $appliance Appliance ID. (required)
     * @param  string $image Basename of the image file included in the app. Ex: \&quot;ico_io\&quot; (required)
     * @param  string $name Signal name (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Crhg\RemoClient\Model\Signal, HTTP status code, HTTP response headers (array of strings)
     */
    public function appliancesApplianceSignalsPostWithHttpInfo($message, $appliance, $image, $name)
    {
        $returnType = '\Crhg\RemoClient\Model\Signal';
        $request = $this->appliancesApplianceSignalsPostRequest($message, $appliance, $image, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Crhg\RemoClient\Model\Signal',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appliancesApplianceSignalsPostAsync
     *
     * 
     *
     * @param  string $message JSON serialized object describing infrared signals. Includes \&quot;data\&quot;, \&quot;freq\&quot; and \&quot;format\&quot; keys. (required)
     * @param  string $appliance Appliance ID. (required)
     * @param  string $image Basename of the image file included in the app. Ex: \&quot;ico_io\&quot; (required)
     * @param  string $name Signal name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appliancesApplianceSignalsPostAsync($message, $appliance, $image, $name)
    {
        return $this->appliancesApplianceSignalsPostAsyncWithHttpInfo($message, $appliance, $image, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appliancesApplianceSignalsPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $message JSON serialized object describing infrared signals. Includes \&quot;data\&quot;, \&quot;freq\&quot; and \&quot;format\&quot; keys. (required)
     * @param  string $appliance Appliance ID. (required)
     * @param  string $image Basename of the image file included in the app. Ex: \&quot;ico_io\&quot; (required)
     * @param  string $name Signal name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appliancesApplianceSignalsPostAsyncWithHttpInfo($message, $appliance, $image, $name)
    {
        $returnType = '\Crhg\RemoClient\Model\Signal';
        $request = $this->appliancesApplianceSignalsPostRequest($message, $appliance, $image, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appliancesApplianceSignalsPost'
     *
     * @param  string $message JSON serialized object describing infrared signals. Includes \&quot;data\&quot;, \&quot;freq\&quot; and \&quot;format\&quot; keys. (required)
     * @param  string $appliance Appliance ID. (required)
     * @param  string $image Basename of the image file included in the app. Ex: \&quot;ico_io\&quot; (required)
     * @param  string $name Signal name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appliancesApplianceSignalsPostRequest($message, $appliance, $image, $name)
    {
        // verify the required parameter 'message' is set
        if ($message === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message when calling appliancesApplianceSignalsPost'
            );
        }
        // verify the required parameter 'appliance' is set
        if ($appliance === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $appliance when calling appliancesApplianceSignalsPost'
            );
        }
        // verify the required parameter 'image' is set
        if ($image === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image when calling appliancesApplianceSignalsPost'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling appliancesApplianceSignalsPost'
            );
        }

        $resourcePath = '/appliances/{appliance}/signals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($appliance !== null) {
            $resourcePath = str_replace(
                '{' . 'appliance' . '}',
                ObjectSerializer::toPathValue($appliance),
                $resourcePath
            );
        }

        // form params
        if ($message !== null) {
            $formParams['message'] = ObjectSerializer::toFormValue($message);
        }
        // form params
        if ($image !== null) {
            $formParams['image'] = ObjectSerializer::toFormValue($image);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appliancesGet
     *
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Crhg\RemoClient\Model\Appliance[]
     */
    public function appliancesGet()
    {
        list($response) = $this->appliancesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation appliancesGetWithHttpInfo
     *
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Crhg\RemoClient\Model\Appliance[], HTTP status code, HTTP response headers (array of strings)
     */
    public function appliancesGetWithHttpInfo()
    {
        $returnType = '\Crhg\RemoClient\Model\Appliance[]';
        $request = $this->appliancesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Crhg\RemoClient\Model\Appliance[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appliancesGetAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appliancesGetAsync()
    {
        return $this->appliancesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appliancesGetAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appliancesGetAsyncWithHttpInfo()
    {
        $returnType = '\Crhg\RemoClient\Model\Appliance[]';
        $request = $this->appliancesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appliancesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appliancesGetRequest()
    {

        $resourcePath = '/appliances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appliancesPost
     *
     * @param  string $nickname Appliance name (required)
     * @param  string $device Device ID (required)
     * @param  string $image Basename of the image file included in the app. Ex: \&quot;ico_ac_1\&quot; (required)
     * @param  string $model ApplianceModel ID if the appliance we&#39;re trying to create is included in IRDB. (optional)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Crhg\RemoClient\Model\Appliance
     */
    public function appliancesPost($nickname, $device, $image, $model = null)
    {
        list($response) = $this->appliancesPostWithHttpInfo($nickname, $device, $image, $model);
        return $response;
    }

    /**
     * Operation appliancesPostWithHttpInfo
     *
     * @param  string $nickname Appliance name (required)
     * @param  string $device Device ID (required)
     * @param  string $image Basename of the image file included in the app. Ex: \&quot;ico_ac_1\&quot; (required)
     * @param  string $model ApplianceModel ID if the appliance we&#39;re trying to create is included in IRDB. (optional)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Crhg\RemoClient\Model\Appliance, HTTP status code, HTTP response headers (array of strings)
     */
    public function appliancesPostWithHttpInfo($nickname, $device, $image, $model = null)
    {
        $returnType = '\Crhg\RemoClient\Model\Appliance';
        $request = $this->appliancesPostRequest($nickname, $device, $image, $model);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Crhg\RemoClient\Model\Appliance',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appliancesPostAsync
     *
     * 
     *
     * @param  string $nickname Appliance name (required)
     * @param  string $device Device ID (required)
     * @param  string $image Basename of the image file included in the app. Ex: \&quot;ico_ac_1\&quot; (required)
     * @param  string $model ApplianceModel ID if the appliance we&#39;re trying to create is included in IRDB. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appliancesPostAsync($nickname, $device, $image, $model = null)
    {
        return $this->appliancesPostAsyncWithHttpInfo($nickname, $device, $image, $model)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appliancesPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $nickname Appliance name (required)
     * @param  string $device Device ID (required)
     * @param  string $image Basename of the image file included in the app. Ex: \&quot;ico_ac_1\&quot; (required)
     * @param  string $model ApplianceModel ID if the appliance we&#39;re trying to create is included in IRDB. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appliancesPostAsyncWithHttpInfo($nickname, $device, $image, $model = null)
    {
        $returnType = '\Crhg\RemoClient\Model\Appliance';
        $request = $this->appliancesPostRequest($nickname, $device, $image, $model);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appliancesPost'
     *
     * @param  string $nickname Appliance name (required)
     * @param  string $device Device ID (required)
     * @param  string $image Basename of the image file included in the app. Ex: \&quot;ico_ac_1\&quot; (required)
     * @param  string $model ApplianceModel ID if the appliance we&#39;re trying to create is included in IRDB. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appliancesPostRequest($nickname, $device, $image, $model = null)
    {
        // verify the required parameter 'nickname' is set
        if ($nickname === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $nickname when calling appliancesPost'
            );
        }
        // verify the required parameter 'device' is set
        if ($device === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device when calling appliancesPost'
            );
        }
        // verify the required parameter 'image' is set
        if ($image === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image when calling appliancesPost'
            );
        }

        $resourcePath = '/appliances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($nickname !== null) {
            $formParams['nickname'] = ObjectSerializer::toFormValue($nickname);
        }
        // form params
        if ($model !== null) {
            $formParams['model'] = ObjectSerializer::toFormValue($model);
        }
        // form params
        if ($device !== null) {
            $formParams['device'] = ObjectSerializer::toFormValue($device);
        }
        // form params
        if ($image !== null) {
            $formParams['image'] = ObjectSerializer::toFormValue($image);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation detectappliancePost
     *
     * @param  string $message JSON serialized object describing infrared signals. Includes \&quot;data\&quot;, \&quot;freq\&quot; and \&quot;format\&quot; keys. (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Crhg\RemoClient\Model\ApplianceModelAndParam[]
     */
    public function detectappliancePost($message)
    {
        list($response) = $this->detectappliancePostWithHttpInfo($message);
        return $response;
    }

    /**
     * Operation detectappliancePostWithHttpInfo
     *
     * @param  string $message JSON serialized object describing infrared signals. Includes \&quot;data\&quot;, \&quot;freq\&quot; and \&quot;format\&quot; keys. (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Crhg\RemoClient\Model\ApplianceModelAndParam[], HTTP status code, HTTP response headers (array of strings)
     */
    public function detectappliancePostWithHttpInfo($message)
    {
        $returnType = '\Crhg\RemoClient\Model\ApplianceModelAndParam[]';
        $request = $this->detectappliancePostRequest($message);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Crhg\RemoClient\Model\ApplianceModelAndParam[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation detectappliancePostAsync
     *
     * 
     *
     * @param  string $message JSON serialized object describing infrared signals. Includes \&quot;data\&quot;, \&quot;freq\&quot; and \&quot;format\&quot; keys. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function detectappliancePostAsync($message)
    {
        return $this->detectappliancePostAsyncWithHttpInfo($message)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation detectappliancePostAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $message JSON serialized object describing infrared signals. Includes \&quot;data\&quot;, \&quot;freq\&quot; and \&quot;format\&quot; keys. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function detectappliancePostAsyncWithHttpInfo($message)
    {
        $returnType = '\Crhg\RemoClient\Model\ApplianceModelAndParam[]';
        $request = $this->detectappliancePostRequest($message);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'detectappliancePost'
     *
     * @param  string $message JSON serialized object describing infrared signals. Includes \&quot;data\&quot;, \&quot;freq\&quot; and \&quot;format\&quot; keys. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function detectappliancePostRequest($message)
    {
        // verify the required parameter 'message' is set
        if ($message === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message when calling detectappliancePost'
            );
        }

        $resourcePath = '/detectappliance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($message !== null) {
            $formParams['message'] = ObjectSerializer::toFormValue($message);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation devicesDeviceDeletePost
     *
     * @param  string $device Device ID. (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function devicesDeviceDeletePost($device)
    {
        $this->devicesDeviceDeletePostWithHttpInfo($device);
    }

    /**
     * Operation devicesDeviceDeletePostWithHttpInfo
     *
     * @param  string $device Device ID. (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function devicesDeviceDeletePostWithHttpInfo($device)
    {
        $returnType = '';
        $request = $this->devicesDeviceDeletePostRequest($device);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation devicesDeviceDeletePostAsync
     *
     * 
     *
     * @param  string $device Device ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesDeviceDeletePostAsync($device)
    {
        return $this->devicesDeviceDeletePostAsyncWithHttpInfo($device)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation devicesDeviceDeletePostAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $device Device ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesDeviceDeletePostAsyncWithHttpInfo($device)
    {
        $returnType = '';
        $request = $this->devicesDeviceDeletePostRequest($device);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'devicesDeviceDeletePost'
     *
     * @param  string $device Device ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function devicesDeviceDeletePostRequest($device)
    {
        // verify the required parameter 'device' is set
        if ($device === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device when calling devicesDeviceDeletePost'
            );
        }

        $resourcePath = '/devices/{device}/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($device !== null) {
            $resourcePath = str_replace(
                '{' . 'device' . '}',
                ObjectSerializer::toPathValue($device),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation devicesDeviceHumidityOffsetPost
     *
     * @param  string $device Device ID. (required)
     * @param  int $offset Humidity offset value added to the measured humidity. (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function devicesDeviceHumidityOffsetPost($device, $offset)
    {
        $this->devicesDeviceHumidityOffsetPostWithHttpInfo($device, $offset);
    }

    /**
     * Operation devicesDeviceHumidityOffsetPostWithHttpInfo
     *
     * @param  string $device Device ID. (required)
     * @param  int $offset Humidity offset value added to the measured humidity. (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function devicesDeviceHumidityOffsetPostWithHttpInfo($device, $offset)
    {
        $returnType = '';
        $request = $this->devicesDeviceHumidityOffsetPostRequest($device, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation devicesDeviceHumidityOffsetPostAsync
     *
     * 
     *
     * @param  string $device Device ID. (required)
     * @param  int $offset Humidity offset value added to the measured humidity. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesDeviceHumidityOffsetPostAsync($device, $offset)
    {
        return $this->devicesDeviceHumidityOffsetPostAsyncWithHttpInfo($device, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation devicesDeviceHumidityOffsetPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $device Device ID. (required)
     * @param  int $offset Humidity offset value added to the measured humidity. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesDeviceHumidityOffsetPostAsyncWithHttpInfo($device, $offset)
    {
        $returnType = '';
        $request = $this->devicesDeviceHumidityOffsetPostRequest($device, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'devicesDeviceHumidityOffsetPost'
     *
     * @param  string $device Device ID. (required)
     * @param  int $offset Humidity offset value added to the measured humidity. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function devicesDeviceHumidityOffsetPostRequest($device, $offset)
    {
        // verify the required parameter 'device' is set
        if ($device === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device when calling devicesDeviceHumidityOffsetPost'
            );
        }
        // verify the required parameter 'offset' is set
        if ($offset === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offset when calling devicesDeviceHumidityOffsetPost'
            );
        }

        $resourcePath = '/devices/{device}/humidity_offset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($device !== null) {
            $resourcePath = str_replace(
                '{' . 'device' . '}',
                ObjectSerializer::toPathValue($device),
                $resourcePath
            );
        }

        // form params
        if ($offset !== null) {
            $formParams['offset'] = ObjectSerializer::toFormValue($offset);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation devicesDevicePost
     *
     * @param  string $device Device ID. (required)
     * @param  string $name Signal name (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function devicesDevicePost($device, $name)
    {
        $this->devicesDevicePostWithHttpInfo($device, $name);
    }

    /**
     * Operation devicesDevicePostWithHttpInfo
     *
     * @param  string $device Device ID. (required)
     * @param  string $name Signal name (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function devicesDevicePostWithHttpInfo($device, $name)
    {
        $returnType = '';
        $request = $this->devicesDevicePostRequest($device, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation devicesDevicePostAsync
     *
     * 
     *
     * @param  string $device Device ID. (required)
     * @param  string $name Signal name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesDevicePostAsync($device, $name)
    {
        return $this->devicesDevicePostAsyncWithHttpInfo($device, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation devicesDevicePostAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $device Device ID. (required)
     * @param  string $name Signal name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesDevicePostAsyncWithHttpInfo($device, $name)
    {
        $returnType = '';
        $request = $this->devicesDevicePostRequest($device, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'devicesDevicePost'
     *
     * @param  string $device Device ID. (required)
     * @param  string $name Signal name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function devicesDevicePostRequest($device, $name)
    {
        // verify the required parameter 'device' is set
        if ($device === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device when calling devicesDevicePost'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling devicesDevicePost'
            );
        }

        $resourcePath = '/devices/{device}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($device !== null) {
            $resourcePath = str_replace(
                '{' . 'device' . '}',
                ObjectSerializer::toPathValue($device),
                $resourcePath
            );
        }

        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation devicesDeviceTemperatureOffsetPost
     *
     * @param  string $device Device ID. (required)
     * @param  int $offset Temperature offset value added to the measured temperature. (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function devicesDeviceTemperatureOffsetPost($device, $offset)
    {
        $this->devicesDeviceTemperatureOffsetPostWithHttpInfo($device, $offset);
    }

    /**
     * Operation devicesDeviceTemperatureOffsetPostWithHttpInfo
     *
     * @param  string $device Device ID. (required)
     * @param  int $offset Temperature offset value added to the measured temperature. (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function devicesDeviceTemperatureOffsetPostWithHttpInfo($device, $offset)
    {
        $returnType = '';
        $request = $this->devicesDeviceTemperatureOffsetPostRequest($device, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation devicesDeviceTemperatureOffsetPostAsync
     *
     * 
     *
     * @param  string $device Device ID. (required)
     * @param  int $offset Temperature offset value added to the measured temperature. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesDeviceTemperatureOffsetPostAsync($device, $offset)
    {
        return $this->devicesDeviceTemperatureOffsetPostAsyncWithHttpInfo($device, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation devicesDeviceTemperatureOffsetPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $device Device ID. (required)
     * @param  int $offset Temperature offset value added to the measured temperature. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesDeviceTemperatureOffsetPostAsyncWithHttpInfo($device, $offset)
    {
        $returnType = '';
        $request = $this->devicesDeviceTemperatureOffsetPostRequest($device, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'devicesDeviceTemperatureOffsetPost'
     *
     * @param  string $device Device ID. (required)
     * @param  int $offset Temperature offset value added to the measured temperature. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function devicesDeviceTemperatureOffsetPostRequest($device, $offset)
    {
        // verify the required parameter 'device' is set
        if ($device === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device when calling devicesDeviceTemperatureOffsetPost'
            );
        }
        // verify the required parameter 'offset' is set
        if ($offset === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offset when calling devicesDeviceTemperatureOffsetPost'
            );
        }

        $resourcePath = '/devices/{device}/temperature_offset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($device !== null) {
            $resourcePath = str_replace(
                '{' . 'device' . '}',
                ObjectSerializer::toPathValue($device),
                $resourcePath
            );
        }

        // form params
        if ($offset !== null) {
            $formParams['offset'] = ObjectSerializer::toFormValue($offset);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation devicesGet
     *
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Crhg\RemoClient\Model\Device[]
     */
    public function devicesGet()
    {
        list($response) = $this->devicesGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation devicesGetWithHttpInfo
     *
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Crhg\RemoClient\Model\Device[], HTTP status code, HTTP response headers (array of strings)
     */
    public function devicesGetWithHttpInfo()
    {
        $returnType = '\Crhg\RemoClient\Model\Device[]';
        $request = $this->devicesGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Crhg\RemoClient\Model\Device[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation devicesGetAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesGetAsync()
    {
        return $this->devicesGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation devicesGetAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesGetAsyncWithHttpInfo()
    {
        $returnType = '\Crhg\RemoClient\Model\Device[]';
        $request = $this->devicesGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'devicesGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function devicesGetRequest()
    {

        $resourcePath = '/devices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation signalsSignalDeletePost
     *
     * @param  string $signal Signal ID. (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function signalsSignalDeletePost($signal)
    {
        $this->signalsSignalDeletePostWithHttpInfo($signal);
    }

    /**
     * Operation signalsSignalDeletePostWithHttpInfo
     *
     * @param  string $signal Signal ID. (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function signalsSignalDeletePostWithHttpInfo($signal)
    {
        $returnType = '';
        $request = $this->signalsSignalDeletePostRequest($signal);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation signalsSignalDeletePostAsync
     *
     * 
     *
     * @param  string $signal Signal ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signalsSignalDeletePostAsync($signal)
    {
        return $this->signalsSignalDeletePostAsyncWithHttpInfo($signal)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation signalsSignalDeletePostAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $signal Signal ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signalsSignalDeletePostAsyncWithHttpInfo($signal)
    {
        $returnType = '';
        $request = $this->signalsSignalDeletePostRequest($signal);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'signalsSignalDeletePost'
     *
     * @param  string $signal Signal ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function signalsSignalDeletePostRequest($signal)
    {
        // verify the required parameter 'signal' is set
        if ($signal === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $signal when calling signalsSignalDeletePost'
            );
        }

        $resourcePath = '/signals/{signal}/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($signal !== null) {
            $resourcePath = str_replace(
                '{' . 'signal' . '}',
                ObjectSerializer::toPathValue($signal),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation signalsSignalPost
     *
     * @param  string $signal Signal ID. (required)
     * @param  string $image Basename of the image file included in the app. Ex: \&quot;ico_io\&quot; (required)
     * @param  string $name Signal name (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function signalsSignalPost($signal, $image, $name)
    {
        $this->signalsSignalPostWithHttpInfo($signal, $image, $name);
    }

    /**
     * Operation signalsSignalPostWithHttpInfo
     *
     * @param  string $signal Signal ID. (required)
     * @param  string $image Basename of the image file included in the app. Ex: \&quot;ico_io\&quot; (required)
     * @param  string $name Signal name (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function signalsSignalPostWithHttpInfo($signal, $image, $name)
    {
        $returnType = '';
        $request = $this->signalsSignalPostRequest($signal, $image, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation signalsSignalPostAsync
     *
     * 
     *
     * @param  string $signal Signal ID. (required)
     * @param  string $image Basename of the image file included in the app. Ex: \&quot;ico_io\&quot; (required)
     * @param  string $name Signal name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signalsSignalPostAsync($signal, $image, $name)
    {
        return $this->signalsSignalPostAsyncWithHttpInfo($signal, $image, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation signalsSignalPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $signal Signal ID. (required)
     * @param  string $image Basename of the image file included in the app. Ex: \&quot;ico_io\&quot; (required)
     * @param  string $name Signal name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signalsSignalPostAsyncWithHttpInfo($signal, $image, $name)
    {
        $returnType = '';
        $request = $this->signalsSignalPostRequest($signal, $image, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'signalsSignalPost'
     *
     * @param  string $signal Signal ID. (required)
     * @param  string $image Basename of the image file included in the app. Ex: \&quot;ico_io\&quot; (required)
     * @param  string $name Signal name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function signalsSignalPostRequest($signal, $image, $name)
    {
        // verify the required parameter 'signal' is set
        if ($signal === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $signal when calling signalsSignalPost'
            );
        }
        // verify the required parameter 'image' is set
        if ($image === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image when calling signalsSignalPost'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling signalsSignalPost'
            );
        }

        $resourcePath = '/signals/{signal}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($signal !== null) {
            $resourcePath = str_replace(
                '{' . 'signal' . '}',
                ObjectSerializer::toPathValue($signal),
                $resourcePath
            );
        }

        // form params
        if ($image !== null) {
            $formParams['image'] = ObjectSerializer::toFormValue($image);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation signalsSignalSendPost
     *
     * @param  string $signal Signal ID. (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function signalsSignalSendPost($signal)
    {
        $this->signalsSignalSendPostWithHttpInfo($signal);
    }

    /**
     * Operation signalsSignalSendPostWithHttpInfo
     *
     * @param  string $signal Signal ID. (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function signalsSignalSendPostWithHttpInfo($signal)
    {
        $returnType = '';
        $request = $this->signalsSignalSendPostRequest($signal);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation signalsSignalSendPostAsync
     *
     * 
     *
     * @param  string $signal Signal ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signalsSignalSendPostAsync($signal)
    {
        return $this->signalsSignalSendPostAsyncWithHttpInfo($signal)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation signalsSignalSendPostAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $signal Signal ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signalsSignalSendPostAsyncWithHttpInfo($signal)
    {
        $returnType = '';
        $request = $this->signalsSignalSendPostRequest($signal);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'signalsSignalSendPost'
     *
     * @param  string $signal Signal ID. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function signalsSignalSendPostRequest($signal)
    {
        // verify the required parameter 'signal' is set
        if ($signal === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $signal when calling signalsSignalSendPost'
            );
        }

        $resourcePath = '/signals/{signal}/send';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($signal !== null) {
            $resourcePath = str_replace(
                '{' . 'signal' . '}',
                ObjectSerializer::toPathValue($signal),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersMeGet
     *
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Crhg\RemoClient\Model\User
     */
    public function usersMeGet()
    {
        list($response) = $this->usersMeGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation usersMeGetWithHttpInfo
     *
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Crhg\RemoClient\Model\User, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersMeGetWithHttpInfo()
    {
        $returnType = '\Crhg\RemoClient\Model\User';
        $request = $this->usersMeGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Crhg\RemoClient\Model\User',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersMeGetAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersMeGetAsync()
    {
        return $this->usersMeGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersMeGetAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersMeGetAsyncWithHttpInfo()
    {
        $returnType = '\Crhg\RemoClient\Model\User';
        $request = $this->usersMeGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersMeGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersMeGetRequest()
    {

        $resourcePath = '/users/me';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersMePost
     *
     * @param  string $nickname User&#39;s nickname. (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Crhg\RemoClient\Model\User
     */
    public function usersMePost($nickname)
    {
        list($response) = $this->usersMePostWithHttpInfo($nickname);
        return $response;
    }

    /**
     * Operation usersMePostWithHttpInfo
     *
     * @param  string $nickname User&#39;s nickname. (required)
     *
     * @throws \Crhg\RemoClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Crhg\RemoClient\Model\User, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersMePostWithHttpInfo($nickname)
    {
        $returnType = '\Crhg\RemoClient\Model\User';
        $request = $this->usersMePostRequest($nickname);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Crhg\RemoClient\Model\User',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersMePostAsync
     *
     * 
     *
     * @param  string $nickname User&#39;s nickname. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersMePostAsync($nickname)
    {
        return $this->usersMePostAsyncWithHttpInfo($nickname)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersMePostAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $nickname User&#39;s nickname. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersMePostAsyncWithHttpInfo($nickname)
    {
        $returnType = '\Crhg\RemoClient\Model\User';
        $request = $this->usersMePostRequest($nickname);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersMePost'
     *
     * @param  string $nickname User&#39;s nickname. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersMePostRequest($nickname)
    {
        // verify the required parameter 'nickname' is set
        if ($nickname === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $nickname when calling usersMePost'
            );
        }

        $resourcePath = '/users/me';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($nickname !== null) {
            $formParams['nickname'] = ObjectSerializer::toFormValue($nickname);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
